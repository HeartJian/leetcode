object.defineProperty
问题：
1.无法监听数组 可以通过观察者模式来监听push shift方法 但是无法监听length长度改变后数组扩容，因为此方法需要存在属性才能监听
2.对于对象属性需要深度遍历
newProxy(obj,handler:{
    set(){},get(){}
})



// 深拷贝要考虑
1.symbol 数据不可遍历
2.对象循环引用
let  deepCopy = (obj,map=new Map())=>{
    if(!Object.prototype.toString.call(obj)!='[object Object]') return obj;
    if(map.get(i)){
        return map.get(i)
    }
    const newObj = Arrat.isArray(obj) ?[]:{};
    let keys = [...Object.getOwnPropertyNames(obj),...Objct.getOwnPropertySymbols(obj)];
    for(let i of keys){
        if(obj.hasOwnProperty(i)){
            if(typeof obj[i] === 'object' && obj[i]!= null) {
                map.add(i,obj[i]);
                newObj[i]=deepCopy(obj[i],map)
            }else{
                newObj[i] = obj[i]
            }
        }
    }
    return newObj
}





对于 Object.prototype.toString.call(arg)，若参数为 null 或 undefined，直接返回结果。

Object.prototype.toString.call(null);       // => "[object Null]"

Object.prototype.toString.call(undefined);  // => "[object Undefined]"
若参数不为 null 或 undefined，则将参数转为对象，再作判断。对于原始类型，转为对象的方法即装箱，此处不赘述。

转为对象后，取得该对象的 [Symbol.toStringTag] 属性值（可能会遍历原型链）作为 tag，如无该属性，或该属性值不为字符串类型，则依下表取得 tag, 然后返回 "[object " + tag + "]" 形式的字符串。



WeakSet 与 Set 的区别：

WeakSet 只能储存对象引用，不能存放值，而 Set 对象都可以
WeakSet 对象中储存的对象值都是被弱引用的，即垃圾回收机制不考虑 WeakSet 对该对象的应用，
如果没有其他的变量或属性引用这个对象值，则这个对象将会被垃圾回收掉（不考虑该对象还存在于 WeakSet 中），
所以，WeakSet 对象里有多少个成员元素，取决于垃圾回收机制有没有运行，运行前后成员个数可能不一致，遍历结束之后，有的成员可能取不到了（被垃圾回收了），WeakSet 对象是无法被遍历的（ES6 规定 WeakSet 不可遍历），也没有办法拿到它包含的所有元素
垃圾回收方面，栈内存变量基本上用完就回收了，而推内存中的变量因为存在很多不确定的引用，只有当所有调用的变量全部销毁之后才能回收。


函数是new出来的，this指向实例
函数通过call、apply、bind绑定过，this指向绑定的第一个参数
函数在某个上下文对象中调用（隐式绑定），this指向上下文对象
以上都不是，this指向全局对象

对象上下文(隐式绑定)
function foo() { 
    console.log( this.a );
}
var obj = { 
    a: 2,
    foo: foo
};
obj.foo(); // 2

引式丢失

function foo() { 
    console.log( this.a );
}
var obj = { 
    a: 2,
    foo: foo 
};
var bar = obj.foo; // 函数别名!
var a = "xxxxx"
bar(); // xxxxx

实现call

Function.prototype.callone = function(obj  = window,...args){
    let fun = Symbol();
    obj[fun] = this;
    let res = obj[fun](...args);
    delete obj.fun;
    return res
}

实现bind
Function.prototype.bindone = function(context,...args){
   if(typeof this != "function" ){
    return false
};
   let that =this;
    let fn = function(){
        let args2 = [...arguments,...args];
        // new 出来的对象 this 等级更高 无法Bind
        if(this instanceof fn){
            that.apply(this,args2)
        }else{
            that.apply(context,args2)    
        }
    };
    fn.prototype =that.prototype
    return fn
}


其实，js 在底层存储变量的时候，会在变量的机器码的低位1-3位存储其类型信息

000：对象
010：浮点数
100：字符串
110：布尔
1：整数
but, 对于 undefined 和 null 来说，这两个值的信息存储是有点特殊的。

null：所有机器码均为0
undefined：用 −2^30 整数来表示

Symbol：
//for在全局注册symbol 而symbol()
Symbol.for
let name = Symbol.for("jyy");
let name1 = Symbol.for("jyy");
console.log(name === name1);  // true

. Symbol.keyFor()

这个方法参数是一个通过Symbol.for()创建的symbol类型变量，返回这个symbol变量的描述信息。

let name = Symbol.for("jyy");
console.log(Symbol.keyFor(name)); // "jyy"
let name1 = Symbol("jyy");
console.log(Symbol.keyFor(name1)); // undefined　不能查找Symbol()创建的变量

let person = {
  [Symbol.toStringTag] : "Person"
}

0.3+0.1!= 0.4?
JavaScript中所有数字包括整数和小数都只有一种类型 — Number。它的实现遵循 IEEE 754 标准，使用64位固定长度来表示，也就是标准的 double 双精度浮点数


 javascript是如何保存数字的
JavaScript 里的数字是采用 IEEE 754 标准的 64 位 double 双精度浮点数


sign bit(符号): 用来表示正负号，1位 （0表示正，1表示负）


exponent(指数): 用来表示次方数，11位


mantissa(尾数): 用来表示精确度，52位

0.1 => 0.2 0.0=>0.4 0.00=>0.8 0.000=>1.6 0001 =>1.2 0.00011
=>0.00011001100110011
最终得到1×1.100110011*2^-4 （2进制科学计数法）
sign bit:0
exponent:-4+1023 =>转2进制
mantissa：100110011=》共52位

对阶、尾数运算、规格化、舍入处理、溢出判断。我们来简单看一下 0.1 和 0.2 的计算。

首先是对阶，所谓对阶，就是把阶码调整为相同，比如 0.1 是 1.1001100110011…… * 2^-4，阶码是 -4，而 0.2 就是 1.10011001100110...* 2^-3，阶码是 -3，两个阶码不同，
所以先调整为相同的阶码再进行计算，调整原则是小阶对大阶，也就是 0.1 的 -4 调整为 -3，对应变成 0.11001100110011…… * 2^-3
我们得到结果为 10.0110011001100110011001100110011001100110011001100111 * 2^-3

将这个结果处理一下，即结果规格化，变成 1.0011001100110011001100110011001100110011001100110011(1) * 2^-2

括号里的 1 意思是说计算后这个 1 超出了范围，所以要被舍弃了。

js 内存泄漏
1.dom的引用没删除，导致浏览器去掉dom时无法垃圾回收
2.闭包导致内存泄漏
3.创建了过多的全局变量
3.定时器

如何分析
1.memory拍2次内存快照 并使用一次垃圾回收做对比
2.performance里的录制线变高

老祖宗的差别，link属于XHTML标签，而@import完全是css提供的一种方式。

　　　　link标签除了可以加载css外，还可以做很多其他的事情，比如定义RSS，定义rel连接属性等，@import只能加载CSS。

差别2：加载顺序的差别：当一个页面被夹在的时候（就是被浏览者浏览的时候），link引用的CSS会同时被加载，而@import引用的CSS会等到页面全部被下载完再加载。所以有时候浏览@import加载CSS的页面时会没有样式（就是闪烁），网速慢的时候还挺明显。

差别3：兼容性的差别。由于@import是CSS2.1提出的所以老的浏览器不支持，@import只有在IE5以上的才能识别，而link标签无此问题，完全兼容。

差别4：使用dom控制样式时的差别。当时用JavaScript控制dom去改变样式的时候，只能使用link标签，因为@import不是dom可以控制的（不支持


for in 会把原型链的便利出来
object.keys 不会
调用ToObject(O)将结果赋值给变量obj
调用EnumerableOwnPropertyNames(obj, "key")将结果赋值给变量nameList
调用CreateArrayFromList(nameList)得到最终的结果
声明变量keys值为一个空列表（List类型）
把每个Number类型的属性，按数值大小升序排序，并依次添加到keys中
把每个String类型的属性，按创建时间升序排序，并依次添加到keys中
把每个Symbol类型的属性，按创建时间升序排序，并依次添加到keys中
将keys返回（return keys）
for of


页面间通讯
1.broadcastChannel:同源页面广播
2.postMessage ：可以往iframe页面传递，可跨域，但是必须要有一个window.open后产生的对象
3.sharedwork:另外启动一个线程
4.服务端缓存，同源页面间indexDb stroage 等


Cache-Control字段： 
no-cache 与服务器进行通讯看看是否被修改过再下载
no-store 每次都要求重新下载
max-age 资源在接下来多久被复用

预编译发生在函数执行之前。预编译四部曲为：

创建AO对象
找形参和变量声明，将变量和形参作为AO属性名，值为undefined
将实参和形参相统一
在函数体里找到函数声明，值赋予函数体。最后程序输出变量值的时候，就是从AO对象中拿。

js执行上下文分三种,推入执行栈中调用
全局执行上下文： 代码开始执行时首先进入的环境。
函数执行上下文：函数调用时，会开始执行函数中的代码。
eval执行上下文：不建议使用，可忽略。
那么，执行上下文的周期，分为两个阶段：
创建阶段
创建词法环境
生成变量对象(VO)，建立作用域链、作用域链、作用域链（重要的事说三遍）
确认this指向，并绑定this
执行阶段。这个阶段进行变量赋值，函数引用及执行代码。


var d = 'abc';
function a(){
    console.log("函数a");
};
console.log(a);   // ƒ a(){ console.log("函数a"); }
a();		      // '函数a'
var a = "变量a";  
console.log(a);   // '变量a'
a();			  // a is not a function
var c = 123;

// 栗子预编后相当于：
function a(){
    console.log("函数a");
};
var d;
console.log(a);  // ƒ a(){ console.log("函数a"); }
a(); 			 // '函数a'

a = "变量a";     // 此时变量a赋值，函数声明被覆盖

console.log(a); // "变量a"
a(); 		// a is not a function
https://juejin.cn/post/6971727286856843295


this指向问题
https://juejin.cn/post/6844903862306865165
所有的调用转化为call看问题
func(p1, p2) // func.call(undefined, p1, p2) 
obj.child.method(p1, p2) // func.call(child, p1, p2) 


defer： 几个script标签按顺序加载
会等到所有的defer脚本加载完毕并按照顺序执行，执行完毕后会触发DOMContentLoaded事件。
async ：谁先加载完谁先执行
async脚本的加载不计入DOMContentLoaded事件统计

DOMContentLoaded：DOMContentLoaded 的触发不需要等待图片等其他资源加载完成。
load，页面上所有的资源（图片，音频，视频等）被加载以后才会触发load事件
js脚本需要等css加载完菜执行

sort函数：不传参默认变为utf-8用ASCLL码比较 数字大于大写字母大于小写字母

typeof
使用低位存储了变量的类型信息：
000：对象
1：整数
010：浮点数
100：字符串
110：布尔
有 2 个值比较特殊：
undefined：用 - （−2^30）表示。
null：对应机器码的 NULL 指针，一般是全零。

浏览器跨域
同源策略限制内容有：
Cookie、LocalStorage、IndexedDB 等存储性内容
DOM 节点
AJAX 请求发送后，结果被浏览器拦截了
简单请求
条件1：使用下列方法之一：
GET
HEAD
POST
条件2：Content-Type 的值仅限于下列三者之一：
text/plain
multipart/form-data
application/x-www-form-urlencoded
复杂请求
  if (whitList.includes(origin)) {
    // 设置哪个源可以访问我
    res.setHeader('Access-Control-Allow-Origin', origin)
    // 允许携带哪个头访问我
    res.setHeader('Access-Control-Allow-Headers', 'name')
    // 允许哪个方法访问我
    res.setHeader('Access-Control-Allow-Methods', 'PUT')
    // 允许携带cookie
    res.setHeader('Access-Control-Allow-Credentials', true)
    // 预检的存活时间
    res.setHeader('Access-Control-Max-Age', 6)
    // 允许返回的头
    res.setHeader('Access-Control-Expose-Headers', 'name')

1. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。
CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。
ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的import有点像 Unix 系统的“符号连接”，原始值变了，import加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。

2. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。
运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。
编译时加载: ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，import时采用静态命令的形式。即在import时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。
