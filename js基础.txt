object.defineProperty
问题：
1.无法监听数组 可以通过观察者模式来监听push shift方法 但是无法监听length长度改变后数组扩容，因为此方法需要存在属性才能监听
2.对于对象属性需要深度遍历
newProxy(obj,handler:{
    set(){},get(){}
})



// 深拷贝要考虑
1.symbol 数据不可遍历
2.对象循环引用
let  deepCopy = (obj,map=new Map())=>{
    if(!Object.prototype.toString.call(obj)!='[object Object]') return obj;
    if(map.get(i)){
        return map.get(i)
    }
    const newObj = Arrat.isArray(obj) ?[]:{};
    let keys = [...Object.getOwnPropertyNames(obj),...Objct.getOwnPropertySymbols(obj)];
    for(let i of keys){
        if(obj.hasOwnProperty(i)){
            if(typeof obj[i] === 'object' && obj[i]!= null) {
                map.add(i,obj[i]);
                newObj[i]=deepCopy(obj[i],map)
            }else{
                newObj[i] = obj[i]
            }
        }
    }
    return newObj
}





对于 Object.prototype.toString.call(arg)，若参数为 null 或 undefined，直接返回结果。

Object.prototype.toString.call(null);       // => "[object Null]"

Object.prototype.toString.call(undefined);  // => "[object Undefined]"
若参数不为 null 或 undefined，则将参数转为对象，再作判断。对于原始类型，转为对象的方法即装箱，此处不赘述。

转为对象后，取得该对象的 [Symbol.toStringTag] 属性值（可能会遍历原型链）作为 tag，如无该属性，或该属性值不为字符串类型，则依下表取得 tag, 然后返回 "[object " + tag + "]" 形式的字符串。



WeakSet 与 Set 的区别：

WeakSet 只能储存对象引用，不能存放值，而 Set 对象都可以
WeakSet 对象中储存的对象值都是被弱引用的，即垃圾回收机制不考虑 WeakSet 对该对象的应用，
如果没有其他的变量或属性引用这个对象值，则这个对象将会被垃圾回收掉（不考虑该对象还存在于 WeakSet 中），
所以，WeakSet 对象里有多少个成员元素，取决于垃圾回收机制有没有运行，运行前后成员个数可能不一致，遍历结束之后，有的成员可能取不到了（被垃圾回收了），WeakSet 对象是无法被遍历的（ES6 规定 WeakSet 不可遍历），也没有办法拿到它包含的所有元素
垃圾回收方面，栈内存变量基本上用完就回收了，而推内存中的变量因为存在很多不确定的引用，只有当所有调用的变量全部销毁之后才能回收。


函数是new出来的，this指向实例
函数通过call、apply、bind绑定过，this指向绑定的第一个参数
函数在某个上下文对象中调用（隐式绑定），this指向上下文对象
以上都不是，this指向全局对象

对象上下文(隐式绑定)
function foo() { 
    console.log( this.a );
}
var obj = { 
    a: 2,
    foo: foo
};
obj.foo(); // 2

引式丢失

function foo() { 
    console.log( this.a );
}
var obj = { 
    a: 2,
    foo: foo 
};
var bar = obj.foo; // 函数别名!
var a = "xxxxx"
bar(); // xxxxx

实现call

Function.prototype.callone = function(obj  = window,...args){
    let fun = Symbol();
    obj[fun] = this;
    let res = obj[fun](...args);
    delete obj.fun;
    return res
}

实现bind
Function.prototype.bindone = function(context,...args){
   if(typeof this != "function" ){
    return false
};
   let that =this;
    let fn = function(){
        let args2 = [...arguments,...args];
        // new 出来的对象 this 等级更高 无法Bind
        if(this instanceof fn){
            that.apply(this,args2)
        }else{
            that.apply(context,args2)    
        }
    };
    fn.prototype =that.prototype
    return fn
}


其实，js 在底层存储变量的时候，会在变量的机器码的低位1-3位存储其类型信息

000：对象
010：浮点数
100：字符串
110：布尔
1：整数
but, 对于 undefined 和 null 来说，这两个值的信息存储是有点特殊的。

null：所有机器码均为0
undefined：用 −2^30 整数来表示

Symbol：
//for在全局注册symbol 而symbol()
Symbol.for
let name = Symbol.for("jyy");
let name1 = Symbol.for("jyy");
console.log(name === name1);  // true

. Symbol.keyFor()

这个方法参数是一个通过Symbol.for()创建的symbol类型变量，返回这个symbol变量的描述信息。

let name = Symbol.for("jyy");
console.log(Symbol.keyFor(name)); // "jyy"
let name1 = Symbol("jyy");
console.log(Symbol.keyFor(name1)); // undefined　不能查找Symbol()创建的变量

let person = {
  [Symbol.toStringTag] : "Person"
}

0.3+0.1!= 0.4?
JavaScript中所有数字包括整数和小数都只有一种类型 — Number。它的实现遵循 IEEE 754 标准，使用64位固定长度来表示，也就是标准的 double 双精度浮点数


 javascript是如何保存数字的
JavaScript 里的数字是采用 IEEE 754 标准的 64 位 double 双精度浮点数


sign bit(符号): 用来表示正负号，1位 （0表示正，1表示负）


exponent(指数): 用来表示次方数，11位


mantissa(尾数): 用来表示精确度，52位

0.1 => 0.2 0.0=>0.4 0.00=>0.8 0.000=>1.6 0001 =>1.2 0.00011
=>0.00011001100110011
最终得到1×1.100110011*2^-4 （2进制科学计数法）
sign bit:0
exponent:-4+1023 =>转2进制
mantissa：100110011=》共52位

对阶、尾数运算、规格化、舍入处理、溢出判断。我们来简单看一下 0.1 和 0.2 的计算。

首先是对阶，所谓对阶，就是把阶码调整为相同，比如 0.1 是 1.1001100110011…… * 2^-4，阶码是 -4，而 0.2 就是 1.10011001100110...* 2^-3，阶码是 -3，两个阶码不同，
所以先调整为相同的阶码再进行计算，调整原则是小阶对大阶，也就是 0.1 的 -4 调整为 -3，对应变成 0.11001100110011…… * 2^-3
我们得到结果为 10.0110011001100110011001100110011001100110011001100111 * 2^-3

将这个结果处理一下，即结果规格化，变成 1.0011001100110011001100110011001100110011001100110011(1) * 2^-2

括号里的 1 意思是说计算后这个 1 超出了范围，所以要被舍弃了。

<<<<<<< HEAD
js 内存泄漏
1.dom的引用没删除，导致浏览器去掉dom时无法垃圾回收
2.闭包导致内存泄漏
3.创建了过多的全局变量
3.定时器

如何分析
1.memory拍2次内存快照 并使用一次垃圾回收做对比
2.performance里的录制线变高

老祖宗的差别，link属于XHTML标签，而@import完全是css提供的一种方式。

　　　　link标签除了可以加载css外，还可以做很多其他的事情，比如定义RSS，定义rel连接属性等，@import只能加载CSS。

差别2：加载顺序的差别：当一个页面被夹在的时候（就是被浏览者浏览的时候），link引用的CSS会同时被加载，而@import引用的CSS会等到页面全部被下载完再加载。所以有时候浏览@import加载CSS的页面时会没有样式（就是闪烁），网速慢的时候还挺明显。

差别3：兼容性的差别。由于@import是CSS2.1提出的所以老的浏览器不支持，@import只有在IE5以上的才能识别，而link标签无此问题，完全兼容。

差别4：使用dom控制样式时的差别。当时用JavaScript控制dom去改变样式的时候，只能使用link标签，因为@import不是dom可以控制的（不支持


for in 会把原型链的便利出来
object.keys 不会
调用ToObject(O)将结果赋值给变量obj
调用EnumerableOwnPropertyNames(obj, "key")将结果赋值给变量nameList
调用CreateArrayFromList(nameList)得到最终的结果
声明变量keys值为一个空列表（List类型）
把每个Number类型的属性，按数值大小升序排序，并依次添加到keys中
把每个String类型的属性，按创建时间升序排序，并依次添加到keys中
把每个Symbol类型的属性，按创建时间升序排序，并依次添加到keys中
将keys返回（return keys）
for of

=======

页面间通讯
1.broadcastChannel:同源页面广播
2.postMessage ：可以往iframe页面传递，可跨域，但是必须要有一个window.open后产生的对象
3.sharedwork:另外启动一个线程
4.服务端缓存，同源页面间indexDb stroage 等
>>>>>>> 9403d75e5ede77d1f06316317c70dae943614aa4
