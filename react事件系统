1.组件挂载更新的时候 通过enqueuePutListener 去注册事件
2.事件存储 EventPluginHub.putListener
可见所有的回调函数都以二维数组的形式存储在listenerBank中，根据组件对应的key来进行管理。


SimpleEventPlugin将事件类型划分成了三类, 对应不同的优先级(优先级由低到高):

DiscreteEvent 离散事件. 例如blur、focus、 click、 submit、 touchStart. 这些事件都是离散触发的
UserBlockingEvent 用户阻塞事件. 例如touchMove、mouseMove、scroll、drag、dragOver等等。这些事件会'阻塞'用户的交互。
ContinuousEvent 可连续事件。例如load、error、loadStart、abort、animationEnd. 这个优先级最高，也就是说它们应该是立即同步执行的，这就是Continuous的意义，即可连续的执行，不被打断.
1.注册每一个对应是事件，并用相应的plugin 管理
一个plugin 对象包含了
// event plugin
{
  eventTypes, // 一个数组，包含了所有合成事件相关的信息，包括其对应的原生事件关系
  extractEvents: // 一个函数，当原生事件触发时执行这个函数
}

export type EventTypes = {[key: string]: DispatchConfig};
export type DispatchConfig = {
  dependencies: Array<TopLevelType>, // 依赖的原生事件，表示关联这些事件的触发. ‘简单事件’一般只有一个，复杂事件如onChange会监听多个, 如下图👇
  phasedRegistrationNames?: {    // 两阶段props事件注册名称, React会根据这些名称在组件实例中查找对应的props事件处理器
    bubbled: string,             // 冒泡阶段, 如onClick
    captured: string,            // 捕获阶段，如onClickCapture
  },
  registrationName?: string      // props事件注册名称, 比如onMouseEnter这些不支持冒泡的事件类型，只会定义  registrationName，不会定义phasedRegistrationNames
  eventPriority: EventPriority,  // 事件的优先级，上文已经介绍过了
};



在ReactDOM启动时就会向EventPluginHub注册这些插件：比如simpleeventplugin  plugin 里描述了eventtype 里面有原生时间的依赖关系，事件优先级，两阶段props事件组测名称。
在组件
在props初始化和更新时会进行事件绑定。首先React会判断元素是否是媒体类型，媒体类型的事件是无法在Document监听的，所以会直接在元素上进行绑定。
通过对应的plugin把事件依赖取出来，对比ReactBrowserEventEmitter维护的'已订阅事件表'。如果这个事件未订阅，则根据优先级的不同绑定不同的事件处理器。

调用dispatchevent 把层级关系bookingkeep存起来，开批量渲染开关并调用 handleTopLevel handleTopLevel 会依次执行 plugins 里所有的事件插件。果一个插件检测到自己需要处理的事件类型时，则处理该事件。
通过原生事件类型决定使用哪个合成事件类型（原生 event 的封装对象，例如 SyntheticMouseEvent) 。
如果对象池里有这个类型的实例，则取出这个实例，覆盖其属性，作为本次派发的事件对象（事件对象复用），若没有则新建一个实例。
从点击的原生事件中找到对应 DOM 节点，从 DOM 节点中找到一个最近的React组件实例， 从而找到了一条由这个实例父节点不断向上组成的链， 这个链就是我们要触发合成事件的链
保存当前元素及其父元素上挂在的所有事件回调函数，包括捕获事件(captured)和冒泡事件(bubbled)，保存到事件event的 _dispatchListeners属性上，并且将当前元素及其父元素的react实例（在 v16.x版本中，这里的实例是一个 FiberNode）保存到event的 _dispatchInstances属性上
批处理：到的事件上挂在的 dispatchListeners循环执行executeDispatch， event.isPropagationStopped()为 true时，中断合成事件的向上遍历执行。 invokeGuardedCallbackImpl最终会执行func.apply(context, funcArgs);
反向触发这条链，父-> 子，模拟捕获阶段，触发所有 props 中含有 onClickCapture 的实例
正向触发这条链，子-> 父，模拟冒泡阶段，触发所有 props 中含有 onClick 的实例