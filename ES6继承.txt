
ES5 和 ES6 子类 this 生成顺序不同。ES5 的继承先生成了子类实例，再调用父类的构造函数修饰子类实例，
ES6 的继承先生成父类实例，再调用子类的构造函数修饰父类实例。这个差别使得 ES6 可以继承内置对象。

1.原型链继承

    // 定义父类
    function Parent(name) {
        this.name = name;
    }

    Parent.prototype.getName = function() {
        return this.name;
    };

    // 定义子类
    function Children() {
        this.age = 24;
    }

    // 通过Children的prototype属性和Parent进行关联继承

    Children.prototype = new Parent('陈先生');

    // Children.prototype.constructor === Parent.prototype.constructor = Parent

    var test = new Children();

    // test.constructor === Children.prototype.constructor === Parent

    test.age // 24
    test.getName(); // 陈先生
我们可以发现，整个继承过程，都是通过原型链之间的指向进行委托关联，直到最后形成了”由构造函数所构造“的结局。

2.构造函数继承

    // 定义父类
    function Parent(value) {
        this.language = ['javascript', 'react', 'node.js'];
        this.value = value;
    }
    
    // 定义子类
    function Children() {
    	Parent.apply(this, arguments);
    }

    const test = new Children(666);

    test.language // ['javascript', 'react', 'node.js']
    test.value // 666


    ====================================================================================================
    ====================================ES6的继承原理====================================================
    ====================================================================================================

class Es6Person {}
class Es6WebDeveloper extends Es6Person {}

// true
// Es6WebDeveloper看做一个实例对象
// Es6Person看做一个原型对象
// 因此Es6WebDeveloper继承了Es6Person的所有属性和方法
// 实现了类的静态属性和方法的继承
// 子类的原型是父类
console.log(Es6WebDeveloper.__proto__ === Es6Person)

// true
// 这里类似于 Es6WebDeveloper.prototype = new Es6Person()
// 和ES5的原型链一样
// 子类的原型对象是父类的原型对象的实例
// 子类的实例继承父类的实例
console.log(Es6WebDeveloper.prototype.__proto__ === Es6Person.prototype)
因此以下继承都是可理解的

class A extends Object {
}

A.__proto__ === Object // true
A.prototype.__proto__ === Object.prototype // true


class A {
}

A.__proto__ === Function.prototype // true
A.prototype.__proto__ === Object.prototype // true