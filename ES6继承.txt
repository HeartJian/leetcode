
ES5 和 ES6 子类 this 生成顺序不同。ES5 的继承先生成了子类实例，再调用父类的构造函数修饰子类实例，
ES6 的继承先生成父类实例，再调用子类的构造函数修饰父类实例。这个差别使得 ES6 可以继承内置对象。

1.原型链继承

    // 定义父类
    function Parent(name) {
        this.name = name;
    }

    Parent.prototype.getName = function() {
        return this.name;
    };

    // 定义子类
    function Children() {
        this.age = 24;
    }

    // 通过Children的prototype属性和Parent进行关联继承

    Children.prototype = new Parent('陈先生');

    // Children.prototype.constructor === Parent.prototype.constructor = Parent

    var test = new Children();

    // test.constructor === Children.prototype.constructor === Parent

    test.age // 24
    test.getName(); // 陈先生
我们可以发现，整个继承过程，都是通过原型链之间的指向进行委托关联，直到最后形成了”由构造函数所构造“的结局。

2.构造函数继承

    // 定义父类
    function Parent(value) {
        this.language = ['javascript', 'react', 'node.js'];
        this.value = value;
    }
    
    // 定义子类
    function Children() {
    	Parent.apply(this, arguments);
    }

    const test = new Children(666);

    test.language // ['javascript', 'react', 'node.js']
    test.value // 666


    ====================================================================================================
    ====================================ES6的继承原理====================================================
    ====================================================================================================

class Es6Person {}
class Es6WebDeveloper extends Es6Person {}

// true
// Es6WebDeveloper看做一个实例对象
// Es6Person看做一个原型对象
// 因此Es6WebDeveloper继承了Es6Person的所有属性和方法
// 实现了类的静态属性和方法的继承
// 子类的原型是父类
console.log(Es6WebDeveloper.__proto__ === Es6Person)

// true
// 这里类似于 Es6WebDeveloper.prototype = new Es6Person()
// 和ES5的原型链一样
// 子类的原型对象是父类的原型对象的实例
// 子类的实例继承父类的实例
console.log(Es6WebDeveloper.prototype.__proto__ === Es6Person.prototype)
因此以下继承都是可理解的

class A extends Object {
}

A.__proto__ === Object // true
A.prototype.__proto__ === Object.prototype // true


class A {
}

A.__proto__ === Function.prototype // true
解释：
继承的时候会改写_proto——属性指向extends的对线，没有继承就返回的是一个普通的function

A.prototype.__proto__ === Object.prototype // true
解释：A.prototype 是一个object 
A.prototype = new B()
new B._proto_ =B.prototype;


super关键字
必须调用一次super，生成父类的this然后修饰
在普通方法中，指向父类的原型对象； 在静态方法中，指向父类。

作用域链：
ES5只有函数作用域跟全局作用域，预编译下的执行上下文
调用栈每一个栈帧放一个函数的执行上下文
子可以访问到父，
let const 块级作用域


for循环：
var a = [];
for (let i = 0; i < 10; i++) {
  a[i] = function () {
    console.log(i);
  };
}
a[6](); // 6
上面代码中，变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。
你可能会问，如果每一轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。


作用域链取值：
var x = 10
function fn() {
  console.log(x)
}
function show(f) {
  var x = 20
  (function() {
    f() //10，而不是20
  })()
}
show(fn)
复制代码在fn函数中，取自由变量x的值时，要到哪个作用域中取？——要到创建fn函数的那个作用域中取，无论fn函数将在哪里调用。

闭包
销毁父函数的作用域，创建堆对象给子函数引用
闭包是在函数创建的时候，让函数打包带走的根据函数内的外部引用来过滤作用域链剩下的链。它是在函数创建的时候生成的作用域链的子集，是打包的外部环境。evel 因为没法分析内容，所以直接调用会把整个作用域打包（所以尽量不要用 eval，容易在闭包保存过多的无用变量），而不直接调用则没有闭包。
过滤规则：
全局作用域不会被过滤掉，一定包含。所以在何处调用函数都能访问到。
其余作用域会根据是否内部有变量被当前函数所引用而过滤掉一些。不是每个返回的子函数都会生成闭包。
被引用的作用域也会过滤掉没有被引用的 binding （变量声明）。只把用到的变量打个包。
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
https://juejin.cn/post/6957913856488243237

函数调用栈存储这local环境,this，scope作用域链