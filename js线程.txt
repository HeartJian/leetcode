1、GUI 渲染线程(常驻)

2、JS 引擎线程(常驻)

3、定时器触发线程 (setTimeout)

4、浏览器事件线程 (onclick)(常驻)

5、http 异步线程

6、EventLoop轮询处理线程


GUI渲染线程

负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等

解析html代码(HTML代码本质是字符串)转化为浏览器认识的节点，生成DOM树，也就是DOM Tree
解析css，生成CSSOM(CSS规则树)
把DOM Tree 和CSSOM结合，生成Rendering Tree(渲染树)


当我们修改了一些元素的颜色或者背景色，页面就会重绘(Repaint)
当我们修改元素的尺寸，页面就会回流(Reflow)
当页面需要Repaing和Reflow时GUI线程执行，绘制页面
回流(Reflow)比重绘(Repaint)的成本要高，我们要尽量避免Reflow和Repaint
GUI渲染线程与JS引擎线程是互斥的

当JS引擎执行时GUI线程会被挂起(相当于被冻结了)
GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行

渲染过程Bytes(字节) -> Characters(字符) -> Tokens(词) -> Nodes(节点) -> DOM(DOM树)

如何减少和避免回流重绘
上面我们说到，回流开销太大了，那么我们肯定是要优化的，接着看，其实就是尽量避免上面那些操作

减少逐项更改样式，最好一次性更改 style，或者将样式定义为 class 并一次性更新
避免循环操作DOM，让DOM离线后再修改

创建一个 documentFragment ，在它上面应用所有DOM操作，最后再把它添加到 window.document
先把DOM节点 display:none ( 会触发一次 reflow)，然后做修改后，再把它显示出来
克隆一个DOM节点在内存里，修改之后，与在线的节点相替换


避免多次读取offset等属性，无法避免则将它们缓存到变量
将复杂的元素绝对定位或固定定位，使得它脱离文档流，否则回流代价会很高
改变字体大小也会引发回流，所以尽可能减少这种操作
table布局，一个小改动会造成整个table的重新布局，所以，少用为好


同步和异步任务分别进入不同的执行"场所"，同步的进入主线程，异步的进入Event Table并注册函数
当指定的事情完成时，Event Table会将这个函数移入Event Queue。
主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。
上述过程会不断重复，也就是常说的Event Loop(事件循环)。

那么如此看来我给的答案还是对的。但是js异步有一个机制，就是遇到宏任务，先执行宏任务，将宏任务放入eventqueue，然后在执行微任务，将微任务放入eventqueue最骚的是，这两个queue不是一个queue。当你往外拿的时候先从微任务里拿这个回掉函数，然后再从宏任务的queue上拿宏任务的回掉函数。 我当时看到这我就服了还有这种骚操作。


