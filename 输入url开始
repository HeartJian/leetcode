通过子网掩码跟ip判断是不是可以同一个网络内   
DNS解析获得ip 广播形式发ip,ARP解析Ip后获得mac地址
tcp 3次握手四次挥手（两次不同人发起加上ACK）

物理层
电信号

数据链路层：
PPP点到点协议

网络层
ip 子网掩码 ARP

传输层
tcp udp

应用层
http 

https://juejin.cn/post/6844903604868874247


ETag 如何生成
为何需要公开 hash/etag 算法？
这个和 “消重” 问题有关，详细见：如何避免用户上传相同的文件。
为何在 sha1 值前面加一个字节的标记位0x16或0x96？
0x16 = 22，而 2^22 = 4M。所以前面的 0x16 其实是文件按 4M 分块的意思。
0x96 = 0x80 | 0x16。其中 0x80 表示这个文件是大文件（有多个分块），hash 值也经过了2重的 sha1 计算

1. 对文件内容按4M大小切块；
2. 对每个块做sha1计算；  一种密码散列函数
3，对所有的 sha1 值拼接后做二次 sha1，然后在二次 sha1 值前拼上单个字节，值为0x96；
4. 对拼接好的21字节的二进制数据做url_safe_base64计算，所得结果即为ETag值。


 Browser Process 掌控
1.处理输入
UI thread 需要判断用户输入的是 URL 还是 query；
2.开始导航
当用户点击回车键，UI thread 通知 network thread 获取网页内容，并控制 tab 上的 spinner 展现，表示正在加载中。
network thread 会执行 DNS 查询，随后为请求建立 TLS 连接。
如果 network thread 接收到了重定向请求头如 301，network thread 会通知 UI thread 服务器要求重定向，之后，另外一个 URL 请求会被触发。
3.读取响应
当请求响应返回的时候，network thread 会依据 Content-Type 及 MIME Type sniffing 判断响应内容的格式。
如果响应内容的格式是 HTML ，下一步将会把这些数据传递给 renderer process，如果是 zip 文件或者其它文件，会把相关数据传输给下载管理器。
Safe Browsing 检查也会在此时触发，如果域名或者请求内容匹配到已知的恶意站点，network thread 会展示一个警告页。
此外 CORB 检测也会触发确保敏感数据不会被传递给渲染进程。
4.查找渲染进程
当上述所有检查完成，network thread 确信浏览器可以导航到请求网页，network thread 会通知 UI thread 数据已经准备好，
UI thread 会查找到一个 renderer process 进行网页的渲染。
5.确认导航
进过了上述过程，数据以及渲染进程都可用了， Browser Process 会给 renderer process 发送 IPC 消息来确认导航，
一旦 Browser Process 收到 renderer process 的渲染确认消息，导航过程结束，页面加载过程开始。
地址栏会更新，展示出新页面的网页信息。history tab 会更新，可通过返回键返回导航来的页面，为了让关闭 tab 或者窗口后便于恢复，这些信息会存放在硬盘中。

有 Service Worker 被注册时，其作用域会被保存，当有导航时，network thread 会在注册过的 Service Worker 的作用域中检查相关域名，如果存在对应的 Service worker，
UI thread 会找到一个 renderer process 来处理相关代码，Service Worker 可能会从 cache 中加载数据，从而终止对网络的请求，也可能从网上请求新的数据。