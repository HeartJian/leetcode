事件优先级
最终绑定到root上的事件监听其实是dispatchDiscreteEvent、dispatchUserBlockingUpdate、dispatchEvent这三个中的一个。它们做的事情都是一样的，
以各自的事件优先级去执行真正的事件处理函数。 比如：dispatchDiscreteEvent和dispatchUserBlockingUpdate最终都会以UserBlockingEvent的事件级别去执行事件处理函数。
以某种优先级去执行事件处理函数其实要借助Scheduler中提供的runWithPriority函数来实现事件优先级记录到Scheduler中，
相当于告诉Scheduler：你帮我记录一下当前事件派发的优先级，等React那边创建更新对象（即update）计算更新优先级时直接从你这拿就好了
更新优先级
以setState为例，事件的执行会导致setState执行，而setState本质上是调用enqueueSetState，生成一个update对象，这时候会计算它的更新优先级，即update.lane：
requestUpdateLane，它首先找出Scheduler中记录的优先级：schedulerPriority，然后计算更新优先级：lane，
具体的计算过程在findUpdateLane函数中， 计算过程是一个从高到低依次占用空闲位的操作，update对象创建完成后意味着需要对页面进行更新，
会调用scheduleUpdateOnFiber进入调度，而真正开始调度之前会计算本次产生的更新任务的任务优先级，目的是 与已有任务的任务优先级去做比较，便于做出多任务的调度决策。
任务优先级
调用getNextLanes去计算在本次更新中应该处理的这批lanes（nextLanes），getNextLanes会调用getHighestPriorityLanes去计算任务优先级。
任务优先级计算的原理是这样：更新优先级（update的lane），它会被并入root.pendingLanes，root.pendingLanes经过getNextLanes处理后，
挑出那些应该处理的lanes，传入getHighestPriorityLanes，根据nextLanes找出这些lanes的优先级作为任务优先级
设产生一前一后两个update，它们持有各自的更新优先级，也会被各自的更新任务执行。经过优先级计算，如果后者的任务优先级高于前者的任务优先级，那么会让Scheduler取消前者的任务调度；
调度优先级
一旦任务被调度，那么它就会进入Scheduler，在Scheduler中，这个任务会被包装一下，生成一个属于Scheduler自己的task，这个task持有的优先级就是调度优先级。
它有什么作用呢？在Scheduler中，分别用过期任务队列和未过期任务的队列去管理它内部的task，过期任务的队列中的task根据过 期时间去排序，最早过期的排在前面，便于被最先处理。
而过期时间是由调度优先级计算的出的，不同的调度优先级对应的过期时间不同。

事件优先级、更新优先级、任务优先级、调度优先级，它们之间是递进的关系。事件优先级由事件本身决定，更新优先级由事件计算得出，然后放到root.pendingLanes， 任务优先级来自root.pendingLanes中最紧急的那些lanes对应的优先级，调度优先级根据任务优先级获取。几种优先级环环相扣，保证了高优任务的优先执行。