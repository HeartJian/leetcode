React16架构可以分为三层：

Scheduler（调度器）—— 调度任务的优先级，高优任务优先进入Reconciler
Reconciler（协调器）—— 负责找出变化的组件
Renderer（渲染器）—— 负责将变化的组件渲染到页面上

Scheduler（调度器）
既然我们以浏览器是否有剩余时间作为任务中断的标准，那么我们需要一种机制，当浏览器有剩余时间时通知我们。
其实部分浏览器已经实现了这个API，这就是requestIdleCallback (opens new window)。但是由于以下因素，React放弃使用：
浏览器兼容性
触发频率不稳定，受很多因素影响。比如当我们的浏览器切换tab后，之前tab注册的requestIdleCallback触发的频率会变得很低
基于以上原因，React实现了功能更完备的requestIdleCallbackpolyfill，这就是Scheduler。除了在空闲时触发回调的功能外，Scheduler还提供了多种调度优先级供任务设置。

在React15及以前，Reconciler采用递归的方式创建虚拟DOM，递归过程是不能中断的。如果组件树的层级很深，递归会占用线程很多时间，造成卡顿。
为了解决这个问题，React16将递归的无法中断的更新重构为异步的可中断更新，由于曾经用于递归的虚拟DOM数据结构已经无法满足需要。于是，全新的Fiber架构应运而生。

#Fiber的含义
作为架构来说，之前React15的Reconciler采用递归的方式执行，数据保存在递归调用栈中，所以被称为stack Reconciler。React16的Reconciler基于Fiber节点实现，被称为Fiber Reconciler。
作为静态的数据结构来说，每个Fiber节点对应一个React element，保存了该组件的类型（函数组件/类组件/原生组件...）、对应的DOM节点等信息。
作为动态的工作单元来说，每个Fiber节点保存了本次更新中该组件改变的状态、要执行的工作（需要被删除/被插入页面中/被更新...）。
在React中最多会同时存在两棵Fiber树。当前屏幕上显示内容对应的Fiber树称为current Fiber树，正在内存中构建的Fiber树称为workInProgress Fiber树。
current Fiber树中的Fiber节点被称为current fiber，workInProgress Fiber树中的Fiber节点被称为workInProgress fiber，他们通过alternate属性连接。

currentFiber.alternate === workInProgressFiber;
workInProgressFiber.alternate === currentFiber;
React应用的根节点通过使current指针在不同Fiber树的rootFiber间切换来完成current Fiber树指向的切换。
即当workInProgress Fiber树构建完成交给Renderer渲染在页面上后，应用根节点的current指针指向workInProgress Fiber树，此时workInProgress Fiber树就变为current Fiber树。
每次状态更新都会产生新的workInProgress Fiber树，通过current与workInProgress的替换，完成DOM更新。

// Fiber对应组件的类型 Function/Class/Host...
this.tag = tag;
// key属性
this.key = key;
// 大部分情况同type，某些情况不同，比如FunctionComponent使用React.memo包裹
this.elementType = null;
// 对于 FunctionComponent，指函数本身，对于ClassComponent，指class，对于HostComponent，指DOM节点tagName
this.type = null;
// Fiber对应的真实DOM节点
this.stateNode = null;

//  mount
1.首次执行reactdom时会创建fiberroot和rootfiber 分别为应用的根节点和组件树的根节点
fiberRoot的current会指向当前页面上已渲染内容对应Fiber树，即current Fiber树。
2.接下来进入render阶段，根据组件返回的JSX在内存中依次创建Fiber节点并连接在一起构建Fiber树，被称为workInProgress Fiber树
3.在构建workInProgress Fiber树时会尝试复用current Fiber树中已有的Fiber节点内的属性，在首屏渲染时只有rootFiber存在对应的current fiber
4.workInProgress Fiber树在commit阶段渲染到页面。然后fiberRootNode的current指针指向workInProgress Fiber树使其变为current Fiber 树。

// update
workInProgress fiber的创建可以复用current Fiber树对应的节点数据。

render阶段performSyncWorkOnRoot或performConcurrentWorkOnRoot
区别为是否shouldYeld 如果当前浏览器帧没有剩余时间会中止循环，直到浏览器有空闲时间后再继续遍

performUnitOfWork方法会创建下一个Fiber节点并赋值给workInProgress，并将workInProgress与已创建的Fiber节点连接起来构成Fiber树。
performUnitOfWork会递归，向下深度遍历 
递
为每个fiber节点调用Beginwork方法该方法会根据传入的Fiber节点创建子Fiber节点，并将这两个Fiber节点连接起来。
当遍历到叶子节点（即没有子组件的组件）时就会进入“归”阶段。
归
在“归”阶段会调用completeWork (opens new window)处理Fiber节点。
当某个Fiber节点执行完completeWork，如果其存在兄弟Fiber节点（即fiber.sibling !== null），会进入其兄弟Fiber的“递”阶段。
如果不存在兄弟Fiber，会进入父级Fiber的“归”阶段。
“递”和“归”阶段会交错执行直到“归”到rootFiber。至此，render阶段的工作就结束了


performSyncWorkOnRoot
performConcurrentWorkOnRoot
beginWork
update时：如果current存在，在满足一定条件时可以复用current节点，这样就能克隆current.child作为workInProgress.child，而不需要新建workInProgress.child。
mount时：除fiberRootNode以外，current === null。会根据fiber.tag不同，创建不同类型的子Fiber节点
UPDATE时会因为以下两点didReceiveUpdate === false（即可以直接复用前一次更新的子Fiber，不需要新建子Fiber）
oldProps === newProps && workInProgress.type === current.type，即props与fiber.type不变
!includesSomeLane(renderLanes, updateLanes)，即当前Fiber节点优先级不够

创建子节点switch (workInProgress.tag) {
  case IndeterminateComponent: 
    // ...省略
  case LazyComponent: 
    // ...省略
  case FunctionComponent: 
    // ...省略
  case ClassComponent: 
    // ...省略
  case HostRoot:
    // ...省略
  case HostComponent:
    // ...省略
  case HostText:
    // ...省略
  // ...省略其他类型
}
最终进入reconcileChildren函数
对于mount的组件，他会创建新的子Fiber节点
对于update的组件，他会将当前组件与该组件在上次更新时对应的Fiber节点比较（也就是俗称的Diff算法），将比较的结果生成新Fiber节点：reconcileChildFibers
update时reconcileChildFibers会为生成的Fiber节点带上effectTag属性

循环执行performUnitOfWork方法
beginWork 组件的状态计算、diff的操作以及render函数的执行，发生在beginWork阶段
1.根据current 判断是Mount还是update
2.根据fiber的props与type lanes 设置是否需要didReceiveUpdate ，可直接复用上一次bailoutOnAlreadyFinishedWork
3.根据fiber tag 找不同的组件处理方法updateFunctionComponent
4.执行reconcileChildren ，根据update 来使用reconcileChildFibers（进行diff操作,创建对应的effectTag）
  或者mount mountChildFibers（新建fiber节点）,返回children节点到currentinprogress,创建dom
5.叶子节点为null(currentinprogress),执行completework
completeWork  effect链表的收集、被跳过的优先级的收集
1.根据tag 找到不同的方法处理,对于hostComponent执行bubbleProperties
2.diff props
收集effectlist链
处理style prop
处理DANGEROUSLY_SET_INNER_HTML prop
处理children prop

// setState
调用setState时，意味着组件对应的fiber节点产生了一个更新。setState实际上是生成一个update对象，调用enqueueSetState，将这个update对象连接到fiber节点的updateQueue链表中.


before mutation 
1.处理DOM节点渲染/删除后的 autoFocus、blur逻辑
2.调度useEffect

mutation
遍历effect 根据对应的flags处理函数处理Fiber(placement update deletion)
执行页面上dom的增删改查,
删除时还要删除useEffect的调度函数,调用react生命周期，删除ref
当effect 为update,fiber.tag为FunctionComponent，会调用commitHookEffectListUnmount。该方法会遍历effectList，执行所有useLayoutEffect hook的销毁函数。

layout 
此时dom已被插入
调用生命周期函数 componentDidmount / update,
调用useLayouteffect
更新ref
调用setState回调函数

diff 
diff 对比的是jsx对象跟currentfiber 生成workinprogressfiber
单节点根据key遍历fiber 相同则比较type
多节点：
第一轮遍历：根据key处理更新的节点。
第二轮遍历：处理剩下的不属于更新的节点,新的在前面不需要动,复用节点原先的位置记为lastPlacedIndex,如果新的index>last就不需要移动


// https://react.iamkasong.com/renderer/beforeMutation.html#%E6%A6%82%E8%A7%88
// https://zhuanlan.zhihu.com/p/110789300
// https://zhuanlan.zhihu.com/p/343927857