1.事件处理
在canvas不能够为某个元素绑定事件，所以采用给整个图表容器绑定事件。当进行事件处理的时候，先判断鼠标是否在图形以内。
因为图形经过旋转和缩放，所以需要将鼠标坐标切换到图形坐标系。获取到图形坐标系以后，就可以知道鼠标和图形之间的关系，就可以进行相应的事件处理。

2.渲染
在渲染的时候canvas一旦改变就完全重绘，但是效率很高。
对于SVG而言，假如说散点图有一千个，那么DOM就有一千个节点。如果每一帧都需要把DOM元素进行删除然后添加，效率是非常低的。
所以这里可是使用virtual-Dom的方法，通过维护一个渲染对象列表，每帧将新的渲染对象列表与上一帧的进行diff，获得新增、修改、删除的渲染对象列表，在根据列表对DOM相关节点进行调整。

SVG 绘制的是矢量图，因此对图像进行放大不会失真，不会受到分辨率的影响。
基于 XML，可以为每个元素添加 JavaScript 事件处理器。
每个图形均视为对象，更改对象的属性，图形也会改变。
不适合游戏应用。

svg
line：两对坐标值       <line x1="3" y1="3" x2="48" y2="3"></line>
polyline:用point描述         <polyline points="3 3,48 20,3 53"></polyline>
矩形：用起始点加宽高描述 <rect x="3" y="3" width="80" height="60"></rect>
圆型 ：用x,y的坐标轴加xy轴的半径来确定 <ellipse style="fill:black;" cx="43" cy="65" rx="5" ry="5"></ellipse>
polygon三角形：<polygon points="35 23, 60 43, 35 63" />
path:复合元素
M 表示移动到（moveto）。它用 x 值和 y 值来给定一条新的路径的起始点。可以想象成把你的鼠标放在画布上的某一点以准备开始绘画。大写的 M 表示移动到一个绝对坐标集合（小写的 m 表示移动到一个相对坐标集合）。
L 表示划线到（lineto）。从当前位置到新的位置画一条线。大写的 L 表示移动到一个绝对坐标集合（小写的 l 表示移动到一个相对坐标集合）。
Z 表示闭合路径。通过在当前点和路径的起始点之间画一条直线来闭合形状。
C:三点实现贝塞尔曲线
<path d="
  M 18 3
  L 46 3
  L 46 40
  L 61 40
  L 32 68
  L 3 40
  L 18 40
  Z
"></path>

defs可以隐藏元素图标 g可以把他类似于注册使用
<defs>
<g id="leftalign"></g>
</defs>
然后使用use
<use href="#leftalign"></use>

symbol跟g差不多 不同点在于有一个viewBox属性定义他的x1y1起始点跟宽高
<symbol id="alert" viewBox="0 0 86 86">


带箭头的直线如何实现
直线采用SVG中的line元素，如下所示：

<line x1="0" y1="0" x2="100" y2="200"></line>
1
上面的代码很简洁，(x1,y1)表示起点的坐标，(x2,y2)表示终点的坐标。那么箭头该如何表示呢？

这里需要用到另外一个重要的元素marker。marker标记可以放在直线，折线，多边形和路径的顶点。这些元素可以使用maeker属性的"marker-start"，“marker-mid"和"marker-end”，继承默认情况下或定义的标记的URI，你必须先定义标记，然后才可以通过其URI引用。

<defs> 
  <marker id="markerArrow" markerWidth="13" markerHeight="13" refx="2" refy="6" orient="auto"> 
    <path d="M2,2 L2,11 L10,6 L2,2"style="fill: #000000;" /> 
  </marker> 
</defs>
1
2
3
4
5
再来把刚刚的直线的代码修改一下即可：

<line x1="0" y1="0" x2="100" y2="200" style="stroke:red;marker-end: url(#markerArrow);"></line>
